记录每日收集到的面经以及刷的题目。

 1. 智力题
  岛上有三种颜色的兔子，两只不同颜色的兔子相碰会变成两只第三种颜色的兔子。初始三种颜色兔子的数量满足什么比例会使得最后只有一种颜色的兔子？
  从平衡的角度来看，首先兔子的总数不变，数量足够大时感觉三种颜色会趋于平衡。假设每两只兔子相碰的概率相等，数量越多的颜色，碰撞概率越大，因此会趋于平衡。从应试的角度来说，这样肯定是无解的。那么定量分析，发现考察的是三者数量关系，即假设三种颜色各3，2，1，那么永远不可能演化到只有一种颜色的兔子的情况。考虑到最终只需要有一种颜色，那么只要保证当前初始比例情况下，三种颜色中有两种颜色的数量相等的状态是可达的即可。设x，y，z为三种颜色兔子的数量，k为使两种颜色兔子数量相等状态时的变化量，只需满足(z-y)-k=2k即可。

  看到这些零散的八股知识点很想弄一个软件，以卡片形式记录琐碎知识点，然后可以拖动到不同区域来整理分类，可惜我是前端苦手。
  
  2. 智力题
  有100个饺子，两个人轮流拿，一次可拿1～5个，怎么样可以保证是你自己最后拿？
  倒推一下，如果要保证自己最后拿，那么最后一次剩下的饺子一定是在1\~5之间，如何保证最后剩下的饺子数量呢？显然我们无法控制每轮对手拿多少，但我们能控制一轮（即双方各拿一次）总共拿走多少。控制的前提是，我们需要成为每一轮的后手。且每轮共拿走的数量应该在6\~10之间，显然这里的答案是6。100 mod 6 = 4，由于每轮的后手才可以控制本轮的总量，但最后剩下的4个只有先手的能拿到，因此我们需要成为先手，将这4个拿走，之后成为每一轮的后手即可保证最后拿。
  
  3. 算法题
  粗略看了三四篇面经，算法题在HOT 100里面都有，直接开刷。
  - 1两数之和: 暴力两重循环即可。O(N)的方法为哈希表，即遍历一次，每次遍历插入，后续寻找target-x是在表中即可。重点关注hashmap的语法。
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hashmap;
        for(int i=0;i<nums.size();i++){
            if(hashmap.count(target-nums[i])!=0){
                return {i,hashmap[target-nums[i]]};
            }
            hashmap[nums[i]]=i;
        }
        return {};
    }
};
```
  - 2两数相加：注意优化，其实五月份第一次写这题的思路不错的。


## 杂
虽然现在在用友实习，但是来的第一周我就知道我不会在这里留下来。无关待遇问题，纯属个人选择。这也让我第一次感受到了我的人生，仍是流动的。看到周围三四十的前辈，我能想象，如果处于他们这个年纪或经历，也许会寻求安稳。但我不愿意。如果能成功入职字节，我很想感受字节的氛围，作为本行业的头部公司，如果也让我有静止的感觉，那毕业后我将选择创建自己的事业。趁着我的人生仍是湍流，一往无前吧。
